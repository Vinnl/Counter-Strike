!function(){function e(e,t,i={}){const r=new THREE.Vector3,s=new THREE.Quaternion,a=new THREE.Vector3,l=new THREE.Matrix4,p=new THREE.Matrix4,c=new THREE.Matrix4;i.preserveMatrix=void 0===i.preserveMatrix||i.preserveMatrix,i.preservePosition=void 0===i.preservePosition||i.preservePosition,i.preserveHipPosition=void 0!==i.preserveHipPosition&&i.preserveHipPosition,i.useTargetMatrix=void 0!==i.useTargetMatrix&&i.useTargetMatrix,i.hip=void 0!==i.hip?i.hip:"hip",i.names=i.names||{};const m=t.isObject3D?t.skeleton.bones:n(t),u=e.isObject3D?e.skeleton.bones:n(e);let E,x,d,f,T;if(e.isObject3D?e.skeleton.pose():(i.useTargetMatrix=!0,i.preserveMatrix=!1),i.preservePosition){T=[];for(let e=0;e<u.length;e++)T.push(u[e].position.clone())}if(i.preserveMatrix){e.updateMatrixWorld(),e.matrixWorld.identity();for(let t=0;t<e.children.length;++t)e.children[t].updateMatrixWorld(!0)}if(i.offsets){E=[];for(let e=0;e<u.length;++e)x=u[e],d=i.names[x.name]||x.name,i.offsets[d]&&(x.matrix.multiply(i.offsets[d]),x.matrix.decompose(x.position,x.quaternion,x.scale),x.updateMatrixWorld()),E.push(x.matrixWorld.clone())}for(let t=0;t<u.length;++t){if(x=u[t],d=i.names[x.name]||x.name,f=o(d,m),c.copy(x.matrixWorld),f){if(f.updateMatrixWorld(),i.useTargetMatrix?p.copy(f.matrixWorld):(p.copy(e.matrixWorld).invert(),p.multiply(f.matrixWorld)),a.setFromMatrixScale(p),p.scale(a.set(1/a.x,1/a.y,1/a.z)),c.makeRotationFromQuaternion(s.setFromRotationMatrix(p)),e.isObject3D){const t=u.indexOf(x),n=E?E[t]:l.copy(e.skeleton.boneInverses[t]).invert();c.multiply(n)}c.copyPosition(p)}x.parent&&x.parent.isBone?(x.matrix.copy(x.parent.matrixWorld).invert(),x.matrix.multiply(c)):x.matrix.copy(c),i.preserveHipPosition&&d===i.hip&&x.matrix.setPosition(r.set(0,x.position.y,0)),x.matrix.decompose(x.position,x.quaternion,x.scale),x.updateMatrixWorld()}if(i.preservePosition)for(let e=0;e<u.length;++e)x=u[e],d=i.names[x.name]||x.name,d!==i.hip&&x.position.copy(T[e]);i.preserveMatrix&&e.updateMatrixWorld(!0)}function t(e){const t=new THREE.SkeletonHelper(e.bones[0]);return t.skeleton=e,t}function n(e){return Array.isArray(e)?e:e.bones}function o(e,t){for(let o=0,i=n(t);o<i.length;o++)if(e===i[o].name)return i[o]}function i(e,t){for(;e.isBone;){if(-1!==t.indexOf(e.name))return e;e=e.parent}}function r(e,t,n){n(e,t);for(let o=0;o<e.children.length;o++)r(e.children[o],t.children[o],n)}THREE.SkeletonUtils={},THREE.SkeletonUtils.clone=function(e){const t=new Map,n=new Map,o=e.clone();return r(e,o,(function(e,o){t.set(o,e),n.set(e,o)})),o.traverse((function(e){if(!e.isSkinnedMesh)return;const o=e,i=t.get(e),r=i.skeleton.bones;o.skeleton=i.skeleton.clone(),o.bindMatrix.copy(i.bindMatrix),o.skeleton.bones=r.map((function(e){return n.get(e)})),o.bind(o.skeleton,o.bindMatrix)})),o},THREE.SkeletonUtils.findBoneTrackData=function(e,t){const n=/\[(.*)\]\.(.*)/,o={name:e};for(let i=0;i<t.length;++i){const r=n.exec(t[i].name);r&&e===r[1]&&(o[r[2]]=i)}return o},THREE.SkeletonUtils.getBoneByName=o,THREE.SkeletonUtils.getBones=n,THREE.SkeletonUtils.getEqualsBonesNames=function(e,t){const o=n(e),i=n(t),r=[];e:for(let e=0;e<o.length;e++){const t=o[e].name;for(let e=0;e<i.length;e++)if(t===i[e].name){r.push(t);continue e}}return r},THREE.SkeletonUtils.getHelperFromSkeleton=t,THREE.SkeletonUtils.getNearestBone=i,THREE.SkeletonUtils.getSkeletonOffsets=function(e,r,s={}){const a=new THREE.Vector3,l=new THREE.Vector3,p=new THREE.Vector3,c=new THREE.Vector3,m=new THREE.Vector2,u=new THREE.Vector2;s.hip=void 0!==s.hip?s.hip:"hip",s.names=s.names||{},r.isObject3D||(r=t(r));const E=Object.keys(s.names),x=Object.values(s.names),d=r.isObject3D?r.skeleton.bones:n(r),f=e.isObject3D?e.skeleton.bones:n(e),T=[];let H,h,M,R;for(e.skeleton.pose(),R=0;R<f.length;++R)if(H=f[R],M=s.names[H.name]||H.name,h=o(M,d),h&&M!==s.hip){const e=i(H.parent,E),t=i(h.parent,x);e.updateMatrixWorld(),t.updateMatrixWorld(),a.setFromMatrixPosition(e.matrixWorld),l.setFromMatrixPosition(H.matrixWorld),p.setFromMatrixPosition(t.matrixWorld),c.setFromMatrixPosition(h.matrixWorld),m.subVectors(new THREE.Vector2(l.x,l.y),new THREE.Vector2(a.x,a.y)).normalize(),u.subVectors(new THREE.Vector2(c.x,c.y),new THREE.Vector2(p.x,p.y)).normalize();const n=m.angle()-u.angle(),o=(new THREE.Matrix4).makeRotationFromEuler(new THREE.Euler(0,0,n));H.matrix.multiply(o),H.matrix.decompose(H.position,H.quaternion,H.scale),H.updateMatrixWorld(),T[M]=o}return T},THREE.SkeletonUtils.renameBones=function(e,t){const o=n(e);for(let e=0;e<o.length;++e){const n=o[e];t[n.name]&&(n.name=t[n.name])}return this},THREE.SkeletonUtils.retarget=e,THREE.SkeletonUtils.retargetClip=function(i,r,s,a={}){a.useFirstFramePosition=void 0!==a.useFirstFramePosition&&a.useFirstFramePosition,a.fps=void 0!==a.fps?a.fps:30,a.names=a.names||[],r.isObject3D||(r=t(r));const l=Math.round(s.duration*(a.fps/1e3)*1e3),p=1/a.fps,c=[],m=new THREE.AnimationMixer(r),u=n(i.skeleton),E=[];let x,d,f,T,H;m.clipAction(s).play(),m.update(0),r.updateMatrixWorld();for(let t=0;t<l;++t){const n=t*p;e(i,r,a);for(let e=0;e<u.length;++e)H=a.names[u[e].name]||u[e].name,f=o(H,r.skeleton),f&&(d=u[e],T=E[e]=E[e]||{bone:d},a.hip===H&&(T.pos||(T.pos={times:new Float32Array(l),values:new Float32Array(3*l)}),a.useFirstFramePosition&&(0===t&&(x=d.position.clone()),d.position.sub(x)),T.pos.times[t]=n,d.position.toArray(T.pos.values,3*t)),T.quat||(T.quat={times:new Float32Array(l),values:new Float32Array(4*l)}),T.quat.times[t]=n,d.quaternion.toArray(T.quat.values,4*t));m.update(p),r.updateMatrixWorld()}for(let e=0;e<E.length;++e)T=E[e],T&&(T.pos&&c.push(new THREE.VectorKeyframeTrack(".bones["+T.bone.name+"].position",T.pos.times,T.pos.values)),c.push(new THREE.QuaternionKeyframeTrack(".bones["+T.bone.name+"].quaternion",T.quat.times,T.quat.values)));return m.uncacheAction(s),new THREE.AnimationClip(s.name,-1,c)}}();